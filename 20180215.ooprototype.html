<!DOCTYPE html>
<html>

<head>
    <title>Prototype Pattern</title>
    <meta name="description" content="A basic understand of design patterns">
    <meta name="keywords" content="Programming, Design Patterns">
    <meta http-equiv="x-ua-compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="author" content="Vikas K. Solegaonkar">
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="vendor/highlight/styles/default.css">
    <link href="css/blog-post.css" rel="stylesheet">
</head>

<body>
    <div id="body">
        <h1>Prototype Pattern</h1>
        <hr />
<p>This creational pattern addresses another design problem. There are times when instantiating an object is a very costly operation. It is not possible to go through the entire process again and again. At the same time, we do need many instances of the class. The Prototype pattern is used to address such constraints.</p><p>Prototype is based on cloning. The Factory class contains individual instances of the different configurations of the product class. Based on the parameters passed to the factory method, it clones the particular object and passes on an instance. </p><p>Now here is the catch. How deep should we clone it? We chose cloning because we wanted it to be easier and faster. But if the cloning itself gets complicated, then we are defeating the purpose. On the other hand, if we make a very shallow clone, then we defeat the purpose of cloning itself!</p><p>That depends upon the required functionality. Prototype is very useful when the actual object is trivially simple, but it requires extreme processing to instantiate. We can avoid that processing by using a prototype pattern.</p><p>Consider for example, if we are working on implementing an image processing algorithm. If we want to an object that contains the convolution matrix built out of these images. We want to use this matrix to perform a lot more processing. It is a meaningless effort to rework the convolutions again and again. Also, it is not possible to do all the processing on one instance of this matrix - because the processing will destroy the current data. The Prototype pattern can help us solve such a problem.</p><p>The Prototype holder can evaluate the matrices for once and hold  them within it. On every call to the factory method, it can return a cloned copy of this matrix. The caller can then mess with this copy without disrupting what is contained in the container. Next time we need the matrix, we can just invoke the factory method once again.</p>
<h2>Implementation</h2><hr/><p>Let us now look at how the Prototype pattern in implemented in code:</p><pre><code class='java'>public interface Prototype {
	public abstract Object clone ( );
}

public class ConcretePrototype implements Prototype {
	public Object clone() {
		return super.clone();
	}
}

public class Client {
	public static void main( String arg[] ) {
		ConcretePrototype obj1= new ConcretePrototype ();
		ConcretePrototype obj2 = ConcretePrototype)obj1.clone();
	}
}
</code></pre>

    </div>
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
    <script src="vendor/highlight/highlight.pack.js"></script>
    <script src="scripts/blog.js"></script>
</body>

</html>